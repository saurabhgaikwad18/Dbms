 1.Consider table Stud(Roll, Att,Status) 
Write a PL/SQL block for following requirement and handle the exceptions.
Roll no. of student will be entered by user. Attendance of roll no. entered by user will be checked in
Stud table. If attendance is less than 75% then display the message “Term not granted” and set the
status in stud table as “D”. Otherwise display message “Term granted” and set the status in stud
table as “ND”.

-- Create Stud table
CREATE TABLE Stud (
    Roll NUMBER PRIMARY KEY,
    Att NUMBER,
    Status CHAR(2)
);

-- Insert sample data
INSERT INTO Stud (Roll, Att, Status) VALUES (101, 80, NULL);
INSERT INTO Stud (Roll, Att, Status) VALUES (102, 70, NULL);
INSERT INTO Stud (Roll, Att, Status) VALUES (103, 65, NULL);
INSERT INTO Stud (Roll, Att, Status) VALUES (104, 90, NULL);
INSERT INTO Stud (Roll, Att, Status) VALUES (105, 60, NULL);
INSERT INTO Stud (Roll, Att, Status) VALUES (106, 55, NULL);

CREATE TABLE Fine (
    Fine_ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    Roll_no NUMBER,
    Fine_Date DATE,
    Amount NUMBER(10,2),
    CONSTRAINT Fine_PK PRIMARY KEY (Fine_ID),
    CONSTRAINT Fine_FK FOREIGN KEY (Roll_no) REFERENCES Borrower(Roll_no)
);

DECLARE
    v_roll_no    NUMBER;
    v_book_name  VARCHAR2(100);
    v_issue_date DATE;
    v_days_late  NUMBER;
    v_fine_amt   NUMBER;
    v_status     CHAR(1) := 'R'; -- Status 'R' for returned

    -- Custom exceptions
    overdue_exception EXCEPTION;
    invalid_roll_exception EXCEPTION;

    -- Fine details
    v_fine_date DATE := SYSDATE;

BEGIN
    -- Accept roll_no & name of book from user
    v_roll_no := &roll_no; -- Prompt user to enter roll number
    v_book_name := '&book_name'; -- Prompt user to enter book name

    -- Retrieve issue date and status of the book
    SELECT DateofIssue, Status
    INTO v_issue_date, v_status
    FROM Borrower
    WHERE Roll_no = v_roll_no AND NameofBook = v_book_name;

    -- Check if the book has already been returned
    IF v_status = 'R' THEN
        RAISE_APPLICATION_ERROR(-20001, 'Book has already been returned.');
    END IF;

    -- Calculate number of days late
    v_days_late := TRUNC(SYSDATE) - TRUNC(v_issue_date);

    -- Calculate fine amount based on days overdue
    IF v_days_late > 30 THEN
        v_fine_amt := 50 * v_days_late;
    ELSIF v_days_late >= 15 THEN
        v_fine_amt := 5 * v_days_late;
    ELSE
        v_fine_amt := 0; -- No fine if less than 15 days overdue
    END IF;

    -- Insert fine details if fine amount is greater than 0
    IF v_fine_amt > 0 THEN
        INSERT INTO Fine (Roll_no, Fine_Date, Amount)
        VALUES (v_roll_no, v_fine_date, v_fine_amt);
    END IF;

    -- Update status to 'R' (Returned)
    UPDATE Borrower
    SET Status = v_status
    WHERE Roll_no = v_roll_no AND NameofBook = v_book_name;

    -- Commit the transaction
    COMMIT;

    -- Display success message
    DBMS_OUTPUT.PUT_LINE('Book returned successfully. Fine amount: Rs ' || v_fine_amt);

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20002, 'Book not found for the provided roll number and book name.');
    WHEN overdue_exception THEN
        RAISE_APPLICATION_ERROR(-20003, 'Book is overdue by more than 30 days.');
    WHEN invalid_roll_exception THEN
        RAISE_APPLICATION_ERROR(-20004, 'Invalid roll number provided.');
    WHEN others THEN
        RAISE_APPLICATION_ERROR(-20005, 'An error occurred: ' || SQLERRM);
END;
/





Q 2.Write a update, delete trigger on clientmstr table. The System should keep track of the records
that ARE BEING updated or deleted. The old value of updated or deleted records should be added
in audit_trade table. (separate implementation using both row and statement triggers)


CREATE TABLE clientmstr (
    client_id NUMBER PRIMARY KEY,
    client_name VARCHAR2(100),
    client_address VARCHAR2(100)
);

CREATE TABLE audit_trade (
    audit_id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    action VARCHAR2(10),
    client_id NUMBER,
    client_name VARCHAR2(100),
    client_address VARCHAR2(100),
    audit_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (audit_id)
);


INSERT INTO clientmstr (client_id, client_name, client_address)
VALUES (1, 'John Doe', '123 Main St');

INSERT INTO clientmstr (client_id, client_name, client_address)
VALUES (2, 'Alice Smith', '456 Oak Ave');

CREATE OR REPLACE TRIGGER clientmstr_update_delete_row_trigger
AFTER DELETE OR UPDATE ON clientmstr
FOR EACH ROW
BEGIN
    IF DELETING THEN
        INSERT INTO audit_trade (action, client_id, client_name, client_address)
        VALUES ('DELETE', :OLD.client_id, :OLD.client_name, :OLD.client_address);
    ELSIF UPDATING THEN
        INSERT INTO audit_trade (action, client_id, client_name, client_address)
        VALUES ('UPDATE', :OLD.client_id, :OLD.client_name, :OLD.client_address);
    END IF;
END;
/

DELETE FROM clientmstr WHERE client_id = 1;
UPDATE clientmstr SET client_name = 'New Name' WHERE client_id = 2;
SELECT * FROM audit_trade;



CREATE OR REPLACE TRIGGER clientmstr_update_delete_stmt_trigger
AFTER DELETE OR UPDATE ON clientmstr
DECLARE
    v_action VARCHAR2(10);
BEGIN
    IF DELETING THEN
        v_action := 'DELETE';
    ELSIF UPDATING THEN
        v_action := 'UPDATE';
    END IF;

    IF v_action IS NOT NULL THEN
        INSERT INTO audit_trade (action, client_id, client_name, client_address)
        SELECT v_action, OLD.client_id, OLD.client_name, OLD.client_address
        FROM clientmstr OLD;
    END IF;
END;
/

DELETE FROM clientmstr WHERE client_id = 1;
UPDATE clientmstr SET client_name = 'New Name' WHERE client_id = 2;
SELECT * FROM audit_trade;
